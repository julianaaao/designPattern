OCP (Open-Closed Principle) :
확장에 대해서는 열려 있어야 하지만 코드 변경에 대해서는 닫혀 있어야 한다.
기존의 코드의 변경 없이 새로운 행동을 추가할 수 있어야 한다는 것.

데코레이터 패턴 :
주어진 상황 및 용도에 따라 동적 혹은 정적으로 어떤 객체에 책임을 덧붙이는 패턴으로,
기능 확장이 필요할 때 서브클래싱 대신 쓸 수 있는 유연한 대안이 될 수 있다.


------------------------------------------------------------------------------------------------------
Decorator Pattern의 장단점 ?
- 장점 : 객체의 기능을 동적으로 확장할 수 있으며, 상속보다 유연하고, 각 기능을 독립적으로 구현하고 조합할 수 있다.
- 단점 : Decorator의 중첩이 깊어지면 코드가 복잡해지고, 디버깅이 어려워질 수 있다.
        많은 수의 작은 클래스를 생성할 수 있어 관리가 복잡해질 수 있음.


단점 -> ex) whip, mocha, 등등 중첩되는 decorator 수가 많아지면 성능에 영향을 미칠 수 있음.
대안 :
1. 자주 사용되는 조합의 decorator 생성. ex) mocha + whip
ex) chapter3/example/MochaWhip.java

2. 데코레이터 체인 (Chain of Decorators)
여러 데코레이터를 체인 형태로 연결하여 객체에 기능을 추가하는 방식.

3. 데코레이터 팩토리 (Decorator Factory)
데코레이터 객체의 생성을 캡슐화하는 팩토리를 사용하여 데코레이터를 관리하고 적용하는 방식.
ex) chapter3/example/BeverageDecoratorFactory.java
사용예시 : chapter3/example/CoffeeShop.java




데코레이터 패턴 (Decorator Pattern)

목적:
- 기본 객체에 새로운 기능을 추가하는 유연한 방법을 제공.
- 상속 대신 구성(composition)을 통해 기능을 확장 가능.

구조:
- 기본 객체와 동일한 인터페이스를 구현하는 데코레이터 클래스를 사용.
- 데코레이터 클래스는 기본 객체를 감싸고, 그 객체에 새로운 기능을 추가.

특징:
- 기능을 확장하기 위해 여러 데코레이터를 중첩할 수 있음.
- 각 데코레이터는 원래 객체의 메서드를 호출하고 추가 기능을 수행.


데코레이터 체인 (Chain of Decorators)

목적:
- 요청을 처리하기 위해 객체의 체인을 형성.
- 각 객체(또는 데코레이터)는 요청을 처리한 후, 다음 객체로 요청을 전달.

구조:
- 각 데코레이터는 다음 데코레이터에 대한 참조를 유지.
- 각 데코레이터는 요청을 처리하고, 다음 데코레이터로 전달.

특징:
- 각 데코레이터가 처리의 일부를 수행하고, 나머지 처리를 다음 데코레이터로 위임.
- 이는 책임 연쇄 패턴(Chain of Responsibility)과 유사함.